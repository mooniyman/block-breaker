<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ブロック崩し</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #111;
      color: white;
      text-align: center;
    }

    /* 画面切り替え用の共通スタイル */
    #titleScreen, #gameOverScreen, #gameClearScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    canvas {
      background: #222;
      display: block;
      margin: 0 auto;
    }

    button {
      padding: 10px 20px;
      font-size: 18px;
      margin-top: 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <!-- タイトル画面 -->
  <div id="titleScreen">
    <h1>ブロック崩し</h1>
    <button onclick="startGame()">スタート</button>
  </div>

  <!-- ゲームオーバー画面 -->
  <div id="gameOverScreen" style="display:none;">
    <h1>ゲームオーバー</h1>
    <button onclick="returnToTitle()">タイトルに戻る</button>
  </div>

  <!-- ゲームクリア画面 -->
  <div id="gameClearScreen" style="display:none;">
    <h1>ゲームクリア！</h1>
    <button onclick="returnToTitle()">タイトルに戻る</button>
  </div>

  <!-- ゲーム画面 -->
  <canvas id="gameCanvas" width="480" height="320"></canvas>

<script>
  // Canvasの取得と描画コンテキストの設定
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  // ゲーム状態変数
  let ballX, ballY, ballDX, ballDY, ballRadius;
  let paddleX, rightPressed, leftPressed;
  let bricks, brickRowCount, brickColumnCount, brickWidth, brickHeight, brickPadding, brickOffsetTop, brickOffsetLeft;
  let paddleHeight, paddleWidth;
  let gameRunning = false;
  let lives = 3; // 残機数
  let gameInitialized = false; // ブロック初期化フラグ
  let particles = []; // 破片エフェクト用の配列

  // キー操作イベントの登録
  document.addEventListener("keydown", keyDownHandler);
  document.addEventListener("keyup", keyUpHandler);

  function keyDownHandler(e) {
    if (e.key === "Right" || e.key === "ArrowRight") rightPressed = true;
    else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = true;
  }

  function keyUpHandler(e) {
    if (e.key === "Right" || e.key === "ArrowRight") rightPressed = false;
    else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = false;
  }

  // ゲーム初期化（ブロックは初回のみ生成）
  function initGame() {
    ballRadius = 10;
    paddleHeight = 10;
    paddleWidth = 75;
    brickRowCount = 3;
    brickColumnCount = 5;
    brickWidth = 75;
    brickHeight = 20;
    brickPadding = 10;
    brickOffsetTop = 30;
    brickOffsetLeft = 30;

    if (!gameInitialized) {
      bricks = [];
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
          bricks[c][r] = { x: 0, y: 0, status: 1 };
        }
      }
      gameInitialized = true;
    }
  }

  // ボール描画（立体風グラデーション）
  function drawBall() {
    const gradient = ctx.createRadialGradient(ballX - 3, ballY - 3, 2, ballX, ballY, ballRadius);
    gradient.addColorStop(0, "#ffffff");
    gradient.addColorStop(0.3, "#00ffcc");
    gradient.addColorStop(1, "#006666");

    ctx.beginPath();
    ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();
    ctx.closePath();
  }

  // パドル描画（立体風グラデーション＋ハイライト）
  function drawPaddle() {
    const gradient = ctx.createLinearGradient(paddleX, canvas.height - paddleHeight, paddleX + paddleWidth, canvas.height);
    gradient.addColorStop(0, "#ffff99");
    gradient.addColorStop(0.5, "#ffcc00");
    gradient.addColorStop(1, "#cc9900");

    ctx.beginPath();
    ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
    ctx.fillStyle = gradient;
    ctx.fill();
    ctx.closePath();

    ctx.beginPath();
    ctx.moveTo(paddleX, canvas.height - paddleHeight);
    ctx.lineTo(paddleX + paddleWidth, canvas.height - paddleHeight);
    ctx.strokeStyle = "rgba(255,255,255,0.3)";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.closePath();
  }

  // ブロック描画
  function drawBricks() {
    for (let c = 0; c < brickColumnCount; c++) {
      for (let r = 0; r < brickRowCount; r++) {
        if (bricks[c][r].status === 1) {
          const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
          const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
          bricks[c][r].x = brickX;
          bricks[c][r].y = brickY;
          ctx.beginPath();
          ctx.rect(brickX, brickY, brickWidth, brickHeight);
          ctx.fillStyle = "#ff6666";
          ctx.fill();
          ctx.closePath();
        }
      }
    }
  }

  // 残機表示
  function drawLives() {
    ctx.font = "16px Arial";
    ctx.fillStyle = "#ffffff";
    ctx.fillText("残機: " + lives, canvas.width - 80, 20);
  }

  // 破片生成（ブロック破壊時）
  function createParticles(x, y) {
    for (let i = 0; i < 10; i++) {
      particles.push({
        x: x,
        y: y,
        dx: (Math.random() - 0.5) * 4,
        dy: (Math.random() - 0.5) * 4,
        alpha: 1.0
      });
    }
  }

  // 破片描画と更新
  function drawParticles() {
    for (let i = 0; i < particles.length; i++) {
      const p = particles[i];
      ctx.fillStyle = `rgba(255,102,102,${p.alpha})`;
      ctx.fillRect(p.x, p.y, 4, 4);
      p.x += p.dx;
      p.y += p.dy;
      p.alpha -= 0.02;
    }
    particles = particles.filter(p => p.alpha > 0);
  }

  // ブロックとの衝突判定
  function collisionDetection() {
    for (let c = 0; c < brickColumnCount; c++) {
      for (let r = 0; r < brickRowCount; r++) {
        const b = bricks[c][r];
        if (b.status === 1) {
          if (
            ballX > b.x &&
            ballX < b.x + brickWidth &&
            ballY > b.y &&
            ballY < b.y + brickHeight
          ) {
            ballDY = -ballDY;
            b.status = 0;
            createParticles(b.x + brickWidth / 2, b.y + brickHeight / 2);
          }
        }
      }
    }
  }

  // ゲームクリア判定
  function checkGameClear() {
    for (let c = 0; c < brickColumnCount; c++) {
      for (let r = 0; r < brickRowCount; r++) {
        if (bricks[c][r].status === 1) {
          return false;
        }
      }
    }
    return true;
  }

  // メイン描画ループ
  function draw() {
    if (!gameRunning) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBricks();
    drawParticles();
    drawBall();
    drawPaddle();
    drawLives();
    collisionDetection();

    // 壁との衝突
    if (ballX + ballDX > canvas.width - ballRadius || ballX + ballDX < ballRadius) {
      ballDX = -ballDX;
    }
    if (ballY + ballDY < ballRadius) {
      ballDY = -ballDY;
    } else if (ballY + ballDY > canvas.height - ballRadius) {
      if (ballX > paddleX && ballX < paddleX + paddleWidth) {
        ballDY = -ballDY;
      } else {
        lives--;
        gameRunning = false;

        if (lives > 0) {
          document.getElementById("titleScreen").style.display = "flex"; // 再スタート待機
        } else {
          document.getElementById("gameOverScreen").style.display = "flex"; // ゲームオーバー
        }
        return;
      }
    }

    // パドル操作
    if (rightPressed && paddleX < canvas.width - paddleWidth) {
      paddleX += 7;
    } else if (leftPressed && paddleX > 0) {
      paddleX -= 7;
    }

    // ボール位置更新
    ballX += ballDX;
    ballY += ballDY;

    // ゲームクリア判定
    if (checkGameClear()) {
      gameRunning = false;
      document.getElementById("gameClearScreen").style.display = "flex";
      return;
    }

    requestAnimationFrame(draw);
  }

    // ゲーム開始（毎回スタートボタンで呼ばれる）
    function startGame() {
    // すべての画面を非表示にしてゲーム開始
    document.getElementById("titleScreen").style.display = "none";
    document.getElementById("gameOverScreen").style.display = "none";
    document.getElementById("gameClearScreen").style.display = "none";

    // 初回のみブロックを生成
    if (!gameInitialized) {
      initGame();
    }

    // ボールとパドルの初期化（毎回）
    ballX = canvas.width / 2;
    ballY = canvas.height - 30;
    ballDX = 2;
    ballDY = -2;
    paddleX = (canvas.width - paddleWidth) / 2;
    rightPressed = false;
    leftPressed = false;

    // 破片をリセット
    particles = [];

    // ゲーム開始
    gameRunning = true;
    draw();
  }

    function returnToTitle() {
    // 結果画面を閉じてタイトル画面へ戻る
    document.getElementById("gameOverScreen").style.display = "none";
    document.getElementById("gameClearScreen").style.display = "none";
    document.getElementById("titleScreen").style.display = "flex";

    // ゲームオーバー時はブロックを再生成
    gameInitialized = false;
    lives = 3;
  }
</script>
